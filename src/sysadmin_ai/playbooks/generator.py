"""Playbook generation for exporting sessions as Ansible/Terraform."""

from __future__ import annotations

import logging
from dataclasses import dataclass
from typing import Any

import yaml

logger = logging.getLogger(__name__)


@dataclass
class CommandRecord:
    """Record of an executed command."""

    command: str
    timestamp: str
    user: str
    output: str | None = None
    success: bool = True


class PlaybookGenerator:
    """Generate playbooks from session history."""

    def __init__(self) -> None:
        self.templates = {
            "ansible": self._generate_ansible,
            "terraform": self._generate_terraform,
            "shell": self._generate_shell,
        }

    def export(
        self,
        history: list[CommandRecord],
        format_type: str = "ansible",
    ) -> str:
        """Export session history as a playbook.

        Args:
            history: List of command records
            format_type: Output format (ansible, terraform, shell)

        Returns:
            Generated playbook content
        """
        generator = self.templates.get(format_type, self._generate_shell)
        return generator(history)

    def _generate_ansible(self, history: list[CommandRecord]) -> str:
        """Generate Ansible playbook from command history."""
        tasks = []
        
        for record in history:
            if not record.success:
                continue
                
            task = self._command_to_ansible_task(record.command)
            if task:
                tasks.append(task)

        playbook = [{
            "name": "Generated by SysAdmin AI",
            "hosts": "all",
            "become": True,
            "tasks": tasks,
        }]

        return yaml.dump(playbook, default_flow_style=False, sort_keys=False)

    def _command_to_ansible_task(self, command: str) -> dict[str, Any] | None:
        """Convert a shell command to an Ansible task."""
        cmd_parts = command.split()
        if not cmd_parts:
            return None

        base_cmd = cmd_parts[0]
        
        # Map common commands to Ansible modules
        module_mapping = {
            "apt": self._parse_apt_command,
            "apt-get": self._parse_apt_command,
            "yum": self._parse_yum_command,
            "dnf": self._parse_yum_command,
            "systemctl": self._parse_systemctl_command,
            "service": self._parse_service_command,
            "useradd": self._parse_user_command,
            "groupadd": self._parse_group_command,
            "mkdir": self._parse_mkdir_command,
            "chmod": self._parse_chmod_command,
            "chown": self._parse_chown_command,
            "cp": self._parse_copy_command,
            "scp": self._parse_copy_command,
        }

        parser = module_mapping.get(base_cmd)
        if parser:
            return parser(cmd_parts)
        
        # Default to shell module
        return {
            "name": f"Execute: {command}",
            "shell": command,
        }

    def _parse_apt_command(self, parts: list[str]) -> dict[str, Any]:
        """Parse apt/apt-get command."""
        action = "present"
        packages = []
        
        for i, part in enumerate(parts[1:], 1):
            if part in ["install"]:
                action = "present"
            elif part in ["remove", "purge"]:
                action = "absent"
            elif part in ["update", "upgrade"]:
                return {"name": "Update apt cache", "apt": {"update_cache": True}}
            elif not part.startswith("-"):
                packages.append(part)

        return {
            "name": f"Install packages: {', '.join(packages)}",
            "apt": {
                "name": packages,
                "state": action,
            },
        }

    def _parse_yum_command(self, parts: list[str]) -> dict[str, Any]:
        """Parse yum/dnf command."""
        action = "present"
        packages = []
        
        for part in parts[1:]:
            if part in ["install"]:
                action = "present"
            elif part in ["remove", "erase"]:
                action = "absent"
            elif not part.startswith("-"):
                packages.append(part)

        return {
            "name": f"Manage packages: {', '.join(packages)}",
            "yum": {
                "name": packages,
                "state": action,
            },
        }

    def _parse_systemctl_command(self, parts: list[str]) -> dict[str, Any]:
        """Parse systemctl command."""
        if len(parts) < 3:
            return {"name": f"Execute: {' '.join(parts)}", "shell": ' '.join(parts)}
        
        action = parts[1]
        service = parts[2]
        
        state_map = {
            "start": "started",
            "stop": "stopped",
            "restart": "restarted",
            "reload": "reloaded",
        }
        
        enabled_map = {
            "enable": True,
            "disable": False,
        }

        task = {"name": f"Manage service: {service}", "service": {"name": service}}
        
        if action in state_map:
            task["service"]["state"] = state_map[action]
        if action in enabled_map:
            task["service"]["enabled"] = enabled_map[action]

        return task

    def _parse_service_command(self, parts: list[str]) -> dict[str, Any]:
        """Parse service command."""
        if len(parts) < 3:
            return {"name": f"Execute: {' '.join(parts)}", "shell": ' '.join(parts)}
        
        service = parts[1]
        action = parts[2]
        
        state_map = {
            "start": "started",
            "stop": "stopped",
            "restart": "restarted",
        }

        return {
            "name": f"Manage service: {service}",
            "service": {
                "name": service,
                "state": state_map.get(action, action),
            },
        }

    def _parse_user_command(self, parts: list[str]) -> dict[str, Any]:
        """Parse useradd command."""
        username = parts[-1] if parts else "unknown"
        return {
            "name": f"Create user: {username}",
            "user": {"name": username},
        }

    def _parse_group_command(self, parts: list[str]) -> dict[str, Any]:
        """Parse groupadd command."""
        groupname = parts[-1] if parts else "unknown"
        return {
            "name": f"Create group: {groupname}",
            "group": {"name": groupname},
        }

    def _parse_mkdir_command(self, parts: list[str]) -> dict[str, Any]:
        """Parse mkdir command."""
        path = parts[-1] if parts else "/tmp/unknown"
        return {
            "name": f"Create directory: {path}",
            "file": {
                "path": path,
                "state": "directory",
            },
        }

    def _parse_chmod_command(self, parts: list[str]) -> dict[str, Any]:
        """Parse chmod command."""
        if len(parts) >= 3:
            mode = parts[1]
            path = parts[2]
            return {
                "name": f"Set permissions on {path}",
                "file": {
                    "path": path,
                    "mode": mode,
                },
            }
        return {"name": f"Execute: {' '.join(parts)}", "shell": ' '.join(parts)}

    def _parse_chown_command(self, parts: list[str]) -> dict[str, Any]:
        """Parse chown command."""
        if len(parts) >= 3:
            owner = parts[1]
            path = parts[2]
            return {
                "name": f"Set ownership on {path}",
                "file": {
                    "path": path,
                    "owner": owner,
                },
            }
        return {"name": f"Execute: {' '.join(parts)}", "shell": ' '.join(parts)}

    def _parse_copy_command(self, parts: list[str]) -> dict[str, Any]:
        """Parse cp/scp command."""
        if len(parts) >= 3:
            src = parts[1]
            dest = parts[2]
            return {
                "name": f"Copy {src} to {dest}",
                "copy": {
                    "src": src,
                    "dest": dest,
                },
            }
        return {"name": f"Execute: {' '.join(parts)}", "shell": ' '.join(parts)}

    def _generate_terraform(self, history: list[CommandRecord]) -> str:
        """Generate Terraform configuration from command history."""
        resources = []
        
        for record in history:
            if not record.success:
                continue
            resource = self._command_to_terraform_resource(record.command)
            if resource:
                resources.append(resource)

        # Combine into a terraform configuration
        config = '# Generated by SysAdmin AI\n\nterraform {\n  required_version = ">= 1.0"\n}\n\n'
        config += '\n'.join(resources)
        
        return config

    def _command_to_terraform_resource(self, command: str) -> str | None:
        """Convert a command to Terraform resource (where applicable)."""
        cmd_parts = command.split()
        if not cmd_parts:
            return None

        base_cmd = cmd_parts[0]
        
        # Only some commands map to Terraform
        if base_cmd == "useradd" and len(cmd_parts) >= 2:
            username = cmd_parts[-1]
            return f'''resource "null_resource" "user_{username}" {{
  provisioner "local-exec" {{
    command = "useradd {username}"
  }}
}}
'''
        elif base_cmd == "mkdir" and len(cmd_parts) >= 2:
            path = cmd_parts[-1]
            return f'''resource "local_file" "dir_{path.replace('/', '_')}" {{
  content  = ""
  filename = "{path}/.gitkeep"
  file_permission = "0644"
}}
'''
        
        return f'''# Command not directly convertible to Terraform:
# {command}
'''

    def _generate_shell(self, history: list[CommandRecord]) -> str:
        """Generate shell script from command history."""
        lines = [
            "#!/bin/bash",
            "# Generated by SysAdmin AI",
            "",
            "set -euo pipefail",
            "",
        ]
        
        for record in history:
            lines.append(f"# Executed by {record.user} at {record.timestamp}")
            if record.success:
                lines.append(record.command)
            else:
                lines.append(f"# FAILED: {record.command}")
            lines.append("")

        return '\n'.join(lines)
